source('matrixA.r')
source('matrixB.r')
source('traceAB.r')
source('matrixV.r')

library(data.table)
library(parallel)
library(MASS)

options(stringsAsFactors = F)
args = commandArgs(trailingOnly = TRUE)

fn_y1 = args[1]
fn_y2 = args[2]
chr_all_grm_zs.rel = args[3]
chr_all_grm_zs.rel.id = args[4]
fam_f = args[5]
map_path = args[6]
dosage_path = args[7]
dout = args[8]
plink_path = args[9]

calculate = function(fn_y1,
                     fn_y2,
                     chr_all_grm_zs.rel,
                     chr_all_grm_zs.rel.id,
                     fam_path,
                     map_path,
                     dosage_path,
                     dout,
                     plink_path,
                     K_ind = 200,
                     M_grm) {
  # """
  # fn_y1: phenotype_y1 path 
  # fn_y2: phenotype_y2 path 
  # chr_all_grm_zs.rel: file path for the entire GRM (generated by PLINK)
  # chr_all_grm_zs.rel.id: file path for id list of GRM (generated by PLINK)
  # fam_path: path of .fam file that contains all siblings and parents
  # map_path: path of .map files for snp-jackknife
  # dosage_path: dosage file path
  # dout: output file path
  # plink_path: plink path
  # M_grm: number of SNPs
  # K_ind: number of individual blocks
  # K_snp: number of SNP blocks
  # """
  
  ## number of parameters = 14
  npara = 14
  numCores <- detectCores()
  n_cores = floor(numCores / 2)

  
  ## read phenotypes
  y1 = as.data.frame(fread(fn_y1)) ## FID, IID, y
  y2 = as.data.frame(fread(fn_y2))
  
  ## read GRMs
  grm_all = as.matrix(fread(chr_all_grm_zs.rel, fill = TRUE, sep = '\t'))
  grm_id = as.data.frame(fread(chr_all_grm_zs.rel.id))
  colnames(grm_id)[1] = 'FID'
  N_grm = dim(grm.all)[1]/2
  grm_sib_id = grm_id[1:N_grm,]

  ## cleaning phenotypes
  pheno_complete = complete.cases(cbind(y1[, 3], y2[, 3]))
  y_all = cbind(y1[pheno_complete, 3], y2[pheno_complete, 3])
  y_all_id = y1[pheno_complete, 2] #IID
  grm_id_left = grm_sib_id[grm_sib_id$IID %in% y_all_id,]
  ta = table(grm_id_left$FID)
  count = attr(ta, "dimnames")[[1]][ta == 2]
  grm_id_left_families = grm_id_left[grm_id_left$FID %in% count,]
  
  N = dim(grm_id_left_families)[1]
  blocks_IID = grm_id_left_families[order(grm_id_left_families$FID), 'IID'] ## reorder
  index = match(blocks_IID, grm_id$IID)
  index2 = c(index, index + N_grm)
  grm_all = grm_all[index2, index2]
  grm_id = grm_id[index,]
  
  y_all = y_all[match(blocks_IID, y_all_id),]
  y_all_id = y_all_id[match(blocks_IID, y_all_id)]
  
  
  ## Point est for the whole dataset
  y1_std = (y_all[, 1] - mean(y_all[, 1])) / sd(y_all[, 1])
  y2_std = (y_all[, 2] - mean(y_all[, 2])) / sd(y_all[, 2])
  A = matrixA(npara, grm_all, N, n_cores)
  B = matrixB(grm_all, y1_std, y2_std, npara, N, n_cores)
  est_all = solve(A, B)
  
  ## Ind Jackknife
  # partition indlist into different blocks
  # note: every individual have two IDs: family ID, i.e. FID, and individual ID, i.e. IID. Each family has two siblings, so that means there will be two individuals that share the same FID. We want to split samples based on FID, so the siblings in the same family will be partitioned into the same block. And, we want to organize the dataset in the way that two siblings are continent in the dataset. So the rows of the data will be like: sib1_fam1, sib2_fam1, sib1_fam2, sib2_fam2, sib1_fam3, sib2_fam3,...
  spliting = sample(K_ind, length(unique(grm_id_left_families$FID)), replace =T)
  est_indblock = matrix(0, K_ind, npara)
  
  K_ind_list = c(1:K_ind)
  est_indblock = mcmapply(k_ind = K_ind_list, function(row) {
    blocks_FID = unique(grm_id_left_families$FID)[spliting == k_ind]
    blocks_tmp = grm_id[grm_id$FID %in% blocks_FID,]
    blocks_IID = blocks_tmp[order(blocks_tmp$FID), 'IID'] ## reorder
    N_indblock = length(blocks_IID)
    index = match(blocks_IID, grm_id$IID)
    index_grm = c(index, index + N)
    grm_indblock = grm_all[-index_grm, -index_grm]
    A_indblock = matrixA(npara, grm_indblock, N - N_indblock, n_cores)
    
    index_y = match(blocks_IID, y_all_id)
    y1_block = y_all[-index_y, 1]
    y1_block_std = (y1_block - mean(y1_block)) / sd(y1_block)
    y2_block = y_all[-index_y, 2]
    y2_block_std = (y2_block - mean(y2_block)) / sd(y2_block)
    B_indblock = matrixB(grm_indblock,
                         y1_block_std,
                         y2_block_std,
                         npara,
                         N - N_indblock,
                         n_cores)
    solve(A_indblock, B_indblock)
    
  }, mc.cores = n_cores)
  
  var_indjack = sum((est_indblock - rowMeans(est_indblock)) ^ 2) * (K_ind - 1) / K_ind
  
  
  ## SNP Jackknife
  
  est_snpblock = matrix(0, K_snp, npara)
  
  # K_snp_list= c(1:K_snp)
  mapfiles = list.files(path = map_path)
  K_snp = length(mapfiles)
  est_indblock = mcmapply(k_snp = 1:K_snp, function(row) {
    kth_block = mapfiles[row]
    CHR = gsub('chr(\\d+)_block.*','\\1',kth_block )
    snpblock = gsub('chr(\\d+)_block(\\d+).map','\\2',kth_block )

    map.f = mapfiles[row]
    dosage.f = paste0(dosage_path , '/chr',CHR, '.dosage.gz')
    dsh_ij = paste0(dout, '/blockgrm/', pheno_y1, '_', pheno_y2, '/')
    if (!dir.exists(dsh_ij)) {
      dir.create(file.path(dsh_ij))
    }
    grmblock.f = paste0(dsh_ij, 'chr', CHR, '_block', snpblock)
    ## call PLINK
    m_block = dim(read.table(map.f, header = F))[1]
    command = paste0(
      plink_path,
      ' --fam ',
      fam.f,
      ' --map ',
      map.f,
      ' --import-dosage ',
      dosage.f,
      ' noheader --make-rel square --out ',
      grmblock.f
    )
    system(command)
    ## read block GRM
    grm_snpblock = as.matrix(fread(paste0(grmblock.f, '.rel')))
    grm_snpblock = grm_snpblock[index2, index2]
    grm_snpblock = (grm_all * M_grm - grm_snpblock * m_block) / (M_grm -m_block)
    system(paste0('rm ', grmblock.f, '.rel'))
    A_snpblock = matrixA(npara, grm_snpblock, N, n_cores)
    B_snpblock = matrixB(grm_snpblock, y1_std, y2_std, npara, N, n_cores)
    solve(A_snpblock, B_snpblock)
    
  }, mc.cores = n_cores)
  
  var_snpjack = sum((est_snpblock - rowMeans(est_snpblock)) ^ 2) * (K_snp -1) / K_snp
  
  ## final output
  return (data.frame(est_all, var_indjack, var_snpjack))
}
